

@frozen
class DynamicResult[V]:
    __type: TypeToken[V]
    __value: V
    __source: Optional[TrackedCode]

    @classmethod
    def unknown_value(cls) -> 'DynamicResult':
        return cls()

    @property
    def __is_resolved(self) -> bool:
        return not isinstance(self.__value, BlackHole)

    def __getattr__(self, name: str) -> 'DynamicResult':
        print(f'__getattr__({name!r})')
        try:
            return DynamicResult(getattr(self.__value, name))
        except AttributeError:
            return DynamicResult.unknown_value()

    def __getitem__(self, key: Any) -> 'DynamicResult':
        print(f'__getitem__({key!r})')
        try:
            return DynamicResult(self.__value[key])
        except KeyError:
            return DynamicResult.unknown_value()

    def __call__(self, *args: Any, **kwds: Any) -> 'DynamicResult':
        try:
            return DynamicResult(self.__value(*args, **kwds))
        except:
            return DynamicResult.unknown_value()

    def __len__(self) -> int:
        return len(self.__value)

    def __str__(self) -> str:
        return f'$({self.__value})'


@frozen
class DynamicResult2[V]:
    type: TypeToken[V]
    value: V
    source: Optional[TrackedCode]

    @classmethod
    def unknown_value(cls) -> 'DynamicResult2':
        return cls()

    @classmethod
    def from_value(cls, value: V) -> 'DynamicResult2':
        return cls()

    @property
    def is_resolved(self) -> bool:
        return not isinstance(self.value, BlackHole)

    def get_attr(self, name: str) -> 'DynamicResult2':
        try:
            return DynamicResult2.from_value(getattr(self.value, name))
        except AttributeError:
            return DynamicResult2.unknown_value()

    def get_item(self, key: Any) -> 'DynamicResult2':
        try:
            return DynamicResult2.from_value(self.value[key])
        except KeyError:
            return DynamicResult2.unknown_value()

    def call(self, *args: Any, **kwds: Any) -> 'DynamicResult2':
        try:
            return DynamicResult2.from_value(self.value(*args, **kwds))
        except:
            return DynamicResult2.unknown_value()

    def __str__(self) -> str:
        return f'$({self.value})'


# UNKNOWN = DynamicResult(BlackHole())
# a = DynamicResult([1,2,3])
# print('UNKNOWN._DynamicResult__is_resolved:', UNKNOWN._DynamicResult__is_resolved)
# print('a._DynamicResult__is_resolved:', a._DynamicResult__is_resolved)
# print('len(a):', len(a))
# print("getattr(a, 'reverse'):", getattr(a, 'reverse'))
# print('a[0]:', a[0])
# for b in a:
#     print('b in a:', b)
# print('end')


@frozen
class Result[V]:
    type: TypeToken[V]
    source: Optional[TrackedCode]

    @property
    def value(self) -> V:
        # return BlackHole()
        raise ValueError('unknown value')

    @property
    def is_resolved(self) -> bool:
        return False

    @property
    def is_traceable(self) -> bool:
        return self.source is not None

    @classmethod
    def unknown_value(
        cls,
        type: TypeToken[V] = TYPE_TOKEN_ANYTHING,
        source: Optional[TrackedCode] = None,
    ) -> 'Result':
        return Result(type, source)

    def cast_to(self, new_type: TypeToken[V]) -> 'Result':
        return evolve(self, type=new_type)

    def trace_to(self, source: Optional[TrackedCode]) -> 'Result':
        return evolve(self, source=source)

    def pretty(self) -> str:
        return f'[{self.type}] {str(self)}'

    # def serialize(self) -> Mapping[str, Any]:
    #     return asdict(self)

    # @classmethod
    # def deserialize(cls, data: Mapping[str, Any]) -> 'SolverResult':
    #     if not isinstance(data, dict):
    #         raise TypeError(f'expected a Mapping, got {data!r}')
    #     value = data['value']
    #     try:
    #         value = UnknownValue.deserialize(value)
    #     except (TypeError, KeyError):
    #         pass
    #     return cls(data['type'], value=value)

    def __str__(self) -> str:
        return '$(?)'


TupleResult: Final[Type[Result]] = Result[Tuple[Result[V]]]
ListResult: Final[Type[Result]] = Result[List[Result[V]]]


@frozen
class Resolved(Result[V]):
    _value: V

    @property
    def value(self) -> V:
        return self._value

    @property
    def is_resolved(self) -> bool:
        return True

    @classmethod
    def from_none(cls, source: Optional[TrackedCode] = None) -> 'Resolved':
        return cls(TYPE_TOKEN_NONE, source, None)

    @classmethod
    def from_int(cls, value: int, source: Optional[TrackedCode] = None) -> 'Resolved':
        return cls(TYPE_TOKEN_INT, source, value)

    @classmethod
    def from_float(cls, value: float, source: Optional[TrackedCode] = None) -> 'Resolved':
        return cls(TYPE_TOKEN_FLOAT, source, value)

    @classmethod
    def from_complex(cls, value: complex, source: Optional[TrackedCode] = None) -> 'Resolved':
        return cls(TYPE_TOKEN_COMPLEX, source, value)

    @classmethod
    def from_string(cls, value: str, source: Optional[TrackedCode] = None) -> 'Resolved':
        return cls(TYPE_TOKEN_STRING, source, value)

    @classmethod
    def from_bool(cls, value: bool, source: Optional[TrackedCode] = None) -> 'Resolved':
        return cls(TYPE_TOKEN_BOOL, source, value)

    @classmethod
    def from_tuple(cls, value: Tuple[V], source: Optional[TrackedCode] = None) -> 'Resolved':
        return cls(TYPE_TOKEN_TUPLE, source, value)

    @classmethod
    def from_list(cls, value: List[V], source: Optional[TrackedCode] = None) -> 'Resolved':
        return cls(TYPE_TOKEN_LIST, source, value)

    @classmethod
    def from_set(cls, value: Set[V], source: Optional[TrackedCode] = None) -> 'Resolved':
        return cls(TYPE_TOKEN_SET, source, value)

    @classmethod
    def from_dict(cls, value: Dict[K, V], source: Optional[TrackedCode] = None) -> 'Resolved':
        return cls(TYPE_TOKEN_DICT, source, value)

    @classmethod
    def from_value(cls, value: V, source: Optional[TrackedCode] = None) -> 'Resolved':
        if value is None:
            return cls.from_none(source=source)
        # if isinstance(value, bool):
        #     return cls.from_bool(value, source=source)
        # if isinstance(value, int):
        #     return cls.from_int(value, source=source)
        # if isinstance(value, float):
        #     return cls.from_float(value, source=source)
        # if isinstance(value, complex):
        #     return cls.from_complex(value, source=source)
        # if isinstance(value, str):
        #     return cls.from_string(value, source=source)
        if isinstance(value, Result):
            raise ValueError('doubly wrapped Result')
        if isinstance(value, BaseException):
            return cls(TYPE_TOKEN_EXCEPTION, source, value)
        if isinstance(value, ClassType):
            return cls(TypeToken.of(value), source, value)
        if isinstance(value, BuiltinFunctionType):
            return cls(TYPE_TOKEN_FUNCTION, source, value)
        if isinstance(value, DefFunctionType):
            return cls(TYPE_TOKEN_FUNCTION, source, value)
        if callable(value):
            return cls(TYPE_TOKEN_FUNCTION, source, value)
        # if isinstance(value, tuple):
        #     return cls.from_tuple(value, source=source)
        # if isinstance(value, list):
        #     return cls.from_list(value, source=source)
        # if isinstance(value, set):
        #     return cls.from_set(value, source=source)
        # if isinstance(value, dict):
        #     return cls.from_dict(value, source=source)
        # d = {}
        # g = (type(d.items()), type(d.keys()), type(d.values()))
        # if isinstance(value, g):
        #     return cls(TYPE_TOKEN_ITERABLE, source, value)
        return cls(TypeToken.of(value), source, value)

    def __str__(self) -> str:
        return str(self._value)


@frozen
class UnresolvedInt(Result[int]):
    min_value: Optional[int] = None
    max_value: Optional[int] = None

    @classmethod
    def unknown_value(
        cls,
        min_value: Optional[int] = None,
        max_value: Optional[int] = None,
        source: Optional[TrackedCode] = None,
    ) -> 'UnresolvedInt':
        return cls(TYPE_TOKEN_INT, source, min_value=min_value, max_value=max_value)

    def __str__(self) -> str:
        return '$(? int)'


@frozen
class UnresolvedFloat(Result[float]):
    min_value: Optional[float] = None
    max_value: Optional[float] = None

    @classmethod
    def unknown_value(
        cls,
        min_value: Optional[float] = None,
        max_value: Optional[float] = None,
        source: Optional[TrackedCode] = None,
    ) -> 'UnresolvedFloat':
        return cls(TYPE_TOKEN_FLOAT, source, min_value=min_value, max_value=max_value)

    def __str__(self) -> str:
        return '$(? float)'


@frozen
class UnresolvedString(Result[str]):
    parts: List[Optional[str]] = field(factory=list)

    @classmethod
    def unknown_value(
        cls,
        parts: Optional[List[Optional[str]]] = None,
        source: Optional[TrackedCode] = None,
    ) -> 'UnresolvedString':
        parts = list(parts) if parts is not None else []
        return cls(TYPE_TOKEN_STRING, source, parts=parts)

    def __str__(self) -> str:
        if not self.parts or (len(self.parts) == 1 and self.parts[0] is None):
            return '$(? str)'
        f = lambda s: '$(?)' if s is None else s
        return ''.join(map(f, self.parts))


@frozen
class UnresolvedIterable(Result[Iterable[V]]):
    parts: List[Result[V]] = field(factory=list)

    @classmethod
    def unknown_value(
        cls,
        parts: Optional[Iterable[Result[V]]] = None,
        source: Optional[TrackedCode] = None,
    ) -> 'UnresolvedIterable':
        parts = list(parts) if parts is not None else []
        return cls(TYPE_TOKEN_ITERABLE, source, parts=parts)

    @classmethod
    def unknown_list(
        cls,
        parts: Optional[Iterable[Result[V]]] = None,
        source: Optional[TrackedCode] = None,
    ) -> 'UnresolvedIterable':
        parts = list(parts) if parts is not None else []
        return cls(TYPE_TOKEN_LIST, source, parts=parts)

    @classmethod
    def unknown_tuple(
        cls,
        parts: Optional[Iterable[Result[V]]] = None,
        source: Optional[TrackedCode] = None,
    ) -> 'UnresolvedIterable':
        parts = list(parts) if parts is not None else []
        return cls(TYPE_TOKEN_TUPLE, source, parts=parts)

    @classmethod
    def unknown_set(
        cls,
        parts: Optional[Iterable[Result[V]]] = None,
        source: Optional[TrackedCode] = None,
    ) -> 'UnresolvedIterable':
        parts = list(parts) if parts is not None else []
        return cls(TYPE_TOKEN_SET, source, parts=parts)

    def __str__(self) -> str:
        if not self.parts:
            return '$(? list)'
        return str(list(map(str, self.parts)))


@frozen
class UnresolvedMapping(Result[Mapping[K, V]]):
    known: Dict[K, Result[V]] = field(factory=dict)

    @classmethod
    def unknown_value(
        cls,
        known: Optional[Mapping[K, Result[V]]] = None,
        source: Optional[TrackedCode] = None,
    ) -> 'UnresolvedMapping':
        known = dict(known) if known is not None else {}
        return cls(TYPE_TOKEN_MAPPING, source, known=known)

    @classmethod
    def unknown_dict(
        cls,
        known: Optional[Mapping[K, Result[V]]] = None,
        source: Optional[TrackedCode] = None,
    ) -> 'UnresolvedMapping':
        known = dict(known) if known is not None else {}
        return cls(TYPE_TOKEN_DICT, source, known=known)

    def __str__(self) -> str:
        return f'$(? map {self.known})'




class TypeMask(enum.Flag):
    NONE = enum.auto()
    BOOL = enum.auto()
    INT = enum.auto()
    FLOAT = enum.auto()
    COMPLEX = enum.auto()
    STRING = enum.auto()
    FUNCTION = enum.auto()
    CLASS = enum.auto()
    EXCEPTION = enum.auto()
    ITERABLE = enum.auto()
    MAPPING = enum.auto()
    OBJECT = enum.auto()
    NUMBER = INT | FLOAT | COMPLEX
    PRIMITIVE = NONE | BOOL | NUMBER | STRING
    DEFINITIONS = FUNCTION | CLASS | EXCEPTION
    OBJECTS = STRING | ITERABLE | MAPPING | OBJECT
    ANY = PRIMITIVE | DEFINITIONS | OBJECT

    @classmethod
    def from_value(cls, value: Any) -> 'TypeMask':
        if value is None:
            return cls.NONE
        if isinstance(value, bool):
            return cls.BOOL
        if isinstance(value, int):
            return cls.INT
        if isinstance(value, float):
            return cls.FLOAT
        if isinstance(value, complex):
            return cls.COMPLEX
        if isinstance(value, str):
            return cls.STRING
        if isinstance(value, BaseException):
            return cls.EXCEPTION
        if isinstance(value, type):
            return cls.CLASS
        if isinstance(value, FunctionWrapper) or callable(value):
            return cls.FUNCTION
        if isinstance(value, (tuple, list, set)):
            return cls.ITERABLE
        if isinstance(value, dict):
            return cls.MAPPING
        d = {}
        g = (type(d.items()), type(d.keys()), type(d.values()))
        if isinstance(value, g):
            return cls.ITERABLE
        return cls.OBJECT

    @property
    def can_be_bool(self) -> bool:
        return bool(self & TypeMask.BOOL)

    @property
    def can_be_int(self) -> bool:
        return bool(self & TypeMask.INT)

    @property
    def can_be_float(self) -> bool:
        return bool(self & TypeMask.FLOAT)

    @property
    def can_be_complex(self) -> bool:
        return bool(self & TypeMask.COMPLEX)

    @property
    def can_be_number(self) -> bool:
        return bool(self & TypeMask.NUMBER)

    @property
    def can_be_string(self) -> bool:
        return bool(self & TypeMask.STRING)

    @property
    def can_be_primitive(self) -> bool:
        return bool(self & TypeMask.PRIMITIVE)

    @property
    def can_be_function(self) -> bool:
        return bool(self & TypeMask.FUNCTION)

    @property
    def can_be_class(self) -> bool:
        return bool(self & TypeMask.CLASS)

    @property
    def can_be_exception(self) -> bool:
        return bool(self & TypeMask.EXCEPTION)

    @property
    def can_be_definitions(self) -> bool:
        return bool(self & TypeMask.DEFINITIONS)

    @property
    def can_be_iterable(self) -> bool:
        return bool(self & TypeMask.ITERABLE)

    @property
    def can_be_mapping(self) -> bool:
        return bool(self & TypeMask.MAPPING)

    @property
    def can_be_object(self) -> bool:
        return bool(self & TypeMask.OBJECT)

    @property
    def can_be_any_object(self) -> bool:
        return bool(self & TypeMask.OBJECTS)

    @property
    def can_have_attributes(self) -> bool:
        return bool(self & ~TypeMask.PRIMITIVE)

    @property
    def can_have_items(self) -> bool:
        mask = TypeMask.STRING | TypeMask.ITERABLE | TypeMask.MAPPING | TypeMask.OBJECT
        return bool(self & mask)


